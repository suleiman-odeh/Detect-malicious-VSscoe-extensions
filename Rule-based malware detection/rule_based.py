import requests
import zipfile
import io
import json
import os
import re

# This method for reading the source code
def read_source_code(file_path):
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
        return file.read()

# This method for saving the suspicious source code
def save_source_code(file_path, source_code):
    with open(file_path, 'w', encoding='utf-8', errors='ignore') as file:
        file.write(source_code)


# These are the regular exprissons
malicious_regex = {

    
    "env_var": re.compile(r"\bprocess\.env"),
    "jsonprecess": re.compile(r"JSON\.stringify\(\s*process\.env\s*\)"),
    "jsonprecess2": re.compile(r'JSON\.stringify\(\s*process\[\s*"env"\s*\]\s*\)'),
    "jsonprecess3": re.compile(r"JSON\.stringify\(\s*process\[\s*env\s*\]\s*\)"),
    "jsonprecess4": re.compile(r"JSON\.stringify\(\s*process\[\s*'env'\s*\]\s*\)"),
    "child_process": re.compile(r"require\s*\(\s*'(child_process|node:child_process)'\s*\)"),
    "child_processimport": re.compile(r"import\s+\w+\s+from\s+'(child_process|node:child_process)'\s*"),
    "child_processimport_spawn_exec": re.compile(r"import\s+\{\s*(spawn|exec)\s*\}\s+from\s+'(child_process|node:child_process)'\s*"),
    "child_process_call_spawn_exec": re.compile(r"require\s*\(\s*'(child_process|node:child_process)'\s*\)\.(spawn|exec)"),
    "exec_spawn": re.compile(r"(exec|spawn)\s*\(\s*.+?\s*,\s*.+?\s*,\s*\{\s*detached\s*:\s*true\s*,\s*stdio\s*:\s*'ignore'\s*\}\s*\)"),
    "spawn_exec_dot": re.compile(r"\b\w+\.\s*(spawn|exec)\s*\(\s*.+?\s*,\s*.+?\s*,\s*\{\s*detached\s*:\s*true\s*,\s*stdio\s*:\s*'ignore'\s*\}\s*\)"),
    "fs": re.compile(r"require\s*\(\s*'fs'\s*\)"),
    "fs_call": re.compile(r"require\s*\(\s*'fs'\s*\)\.(readFile|writeFile|open|readFileSync)"),
    "fsimport": re.compile(r"import\s+\w+\s+from\s+'fs'\s*"),
    "fsimport2": re.compile(r"import\s+\{\s*(readFile|writeFile|readFileSync|open)\s*\}\s+from\s+'fs'\s*"),
    "fs_rrwo": re.compile(r"\b(readFile|open|writeFile|readFileSync)\b"),
    "fs_dot": re.compile(r"[a-zA-Z_]\w*\.\s*(readFile|writeFile|open|readFileSync)\b"),
    "privatedata": re.compile(r"\b(\/etc\/passwd|\.aws\/credentials|\.docker\/config\.json|\/\.kube\/config|\/etc\/hosts|\.ssh\/id_rsa)\b"),
    "privatedata2": re.compile(r"[a-zA-Z_]\w*\.\s*(homedir|userInfo|hostname)\s*\(\s*\)"),
    "global_buffer_from": re.compile(r"global\[\s*Buffer\.from\s*\(.*\)\s*\]"),
    "name_mangling_function": re.compile(r"function\s*_0x[a-zA-Z0-9]*\s*\(.*\)"),
    "jsfuck_obfuscation": re.compile("^\\s*[\\[\\]\\(\\)\\+\\!]{10,}\\s*$"),
    "while_obfuscation": re.compile(r"while\s*\(\s*\!\!\[\]\s*\)\s*\{.*\}"),
    "eval": re.compile(r'\beval\("\x65\x76\x61\x6c"\s*'),
    "eval1": re.compile(r'eval\s*\(\s*atob\s*\(\s*[^)]*\s*\)\s*\)\s*'),
    "http": re.compile(r"require\s*\(\s*'(http|http2|https)'\s*\)"),
    "http_request": re.compile(r"\b(http|https|http2)\.\s*(request|get|post|push)\s*\b"),
}

# This method defined conditions described in thesis. The extensions is suspcious if one of the conditions is true
def check_malicious_regex(code, filename, extension_identifier):
    if (malicious_regex['eval'].search(code) or malicious_regex['eval1'].search(code)):
        return f"Matched: eval in {filename} in {extension_identifier}"

    if (malicious_regex['jsonprecess'].search(code) or 
        malicious_regex['jsonprecess2'].search(code) or 
        malicious_regex['jsonprecess3'].search(code) or 
        malicious_regex['jsonprecess4'].search(code)):
        return f"Matched: exfiltrate environment variables in {filename} in {extension_identifier}"



    childcall=(
        malicious_regex['child_process'].search(code) or 
        malicious_regex['child_processimport'].search(code) or 
        malicious_regex['child_processimport_spawn_exec'].search(code) or 
        malicious_regex['child_process_call_spawn_exec'].search(code)
    )

    childexcute=(
        malicious_regex['exec_spawn'].search(code) or 
        malicious_regex['spawn_exec_dot'].search(code)
    )   

    if(childcall and childexcute):
        return f"Matched: child_process in {filename} in {extension_identifier}"


    if (malicious_regex['while_obfuscation'].search(code) or 
        malicious_regex['global_buffer_from'].search(code) or 
        malicious_regex['jsfuck_obfuscation'].search(code) or 
        malicious_regex['name_mangling_function'].search(code)):
        return f"Matched: obfuscation in {filename} in {extension_identifier}"

    if malicious_regex['privatedata'].search(code):
        return f"Matched: privatedata in {filename} in {extension_identifier}"

    env_and_fs_match = (
        malicious_regex['env_var'].search(code) or
        malicious_regex['fs'].search(code) or
        malicious_regex['fs_call'].search(code) or
        malicious_regex['fsimport'].search(code) or
        malicious_regex['fsimport2'].search(code)
    )

    fs_operations_match = (
        malicious_regex['fs_rrwo'].search(code) or
        malicious_regex['fs_dot'].search(code)
    )

    private_data_match = (
        malicious_regex['privatedata'].search(code) or
        malicious_regex['privatedata2'].search(code)
    )

    http_request_match = (
        malicious_regex['http'].search(code) and
        malicious_regex['http_request'].search(code)
    )

    if (env_and_fs_match and fs_operations_match and private_data_match and http_request_match):
        return f"Matched: sending private data with HTTP request in {filename} in {extension_identifier}"

    return f"No match found in {extension_identifier}"

def main():
    p=0
    source_dir = "vscodesources"
    checked_sources=7
    os.makedirs(source_dir, exist_ok=True)
    api_endpoint = "https://marketplace.visualstudio.com/_apis/public/gallery/extensionquery"
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json;api-version=7.2-preview.1"
    }

    # it will go trhough 39 thousand extensions
    for j in range(1, 40):
        payload = {
            "filters": [
                {
                    "criteria": [{"filterType": 8, "value": "Microsoft.VisualStudio.Code"}],
                    "pageNumber": j,
                    "pageSize": 1000,
                    "sortBy": 0,
                    "sortOrder": 0
                }
            ],
            "assetTypes": [],
            "flags": 214 | 0x100 | 0x200 | 0x20
        }
        #ost request is sent to the API
        response = requests.post(api_endpoint, headers=headers, json=payload)
        if response.status_code == 200:
            data = response.json()
            extensions = data.get("results", [])[0].get("extensions", [])

            for extension in extensions:
                found_badcode=False
                p+=1
                """
                Here adjust the number in line 156 in case it takes too long with checking
                """
                if(p<2):
                    continue
                print(f"number of analysed extensions is {p}")
                extension_publisher_username = extension["publisher"]['publisherName']
                extension_name = extension["extensionName"]
                extension_identifier = f"{extension_publisher_username}.{extension_name}"
                extension_version = extension["versions"][0]["version"]
                vsix_package_url = f"https://marketplace.visualstudio.com/_apis/public/gallery/publishers/{extension_publisher_username}/vsextensions/{extension_name}/{extension_version}/vspackage"

                # get request is sent to the extension's endppint
                response = requests.get(vsix_package_url, headers=headers, stream=True)
                if response.status_code == 200:
                    vsix_package_buffer = io.BytesIO(response.content)
                    source_file_path = os.path.join(source_dir, f"[{extension_identifier}].js")

                    with zipfile.ZipFile(vsix_package_buffer, 'r') as zip_ref, open('rule_based_result.txt', 'a', encoding='utf-8') as result:
                        found_package_json = False
                        found_source = False
                        source = ""
                        # it will check if a main file is exist
                        for file in zip_ref.infolist():
                            if file.filename.casefold() == 'extension/package.json'.casefold():
                                with zip_ref.open(file) as f:
                                    found_package_json = True
                                    package_content = f.read().decode('utf-8', errors='ignore')
                                    package_json = json.loads(package_content)
                                    if "main" in package_json:
                                        main_file = package_json["main"]
                                        source = os.path.normpath(os.path.join(os.path.dirname(file.filename), main_file)).replace('\\', '/')
                                        found_source = True
                                    break
                         
                        # if no main file is found then it will check up to 7 Javascript files
                        # If a match is found it will stop            
                        if not found_source:
                            print("no main so we check other javascript files")
                            for file in zip_ref.infolist():
                                if file.filename.endswith(".js"):
                                    checked_sources-=1
                                    if(checked_sources==0):
                                        break
                                    with zip_ref.open(file) as f:
                                        try:
                                            package_content = f.read().decode('utf-8')
                                            filename=file.filename
                                            resultmatch=check_malicious_regex(package_content,filename,extension_identifier)

                                            if resultmatch!=f"No match found in {extension_identifier}":
                                                found_bad_code = True
                                                result.write(f"{resultmatch}\n")
                                                save_source_code(source_file_path, package_content)
                                                print(resultmatch)
                                                break
                                        except Exception as e:
                                            print(f"Error processing {file.filename} in {extension_identifier}: {e}")
                                            continue  
                        # if a main file is found  
                        if found_source:
                            for file in zip_ref.infolist():
                                if source in file.filename and file.filename.endswith('.js'):
                                    with zip_ref.open(file) as source_file:
                                        package_content = source_file.read().decode('utf-8', errors='ignore')
                                        resultmatch = check_malicious_regex(package_content, file.filename, extension_identifier)
                                        if resultmatch != f"No match found in {extension_identifier}":
                                            found_badcode=True
                                            print(f"{resultmatch}")
                                            result.write(f"{resultmatch}\n")
                                            save_source_code(source_file_path, package_content)
                                            break
                        if not found_badcode:
                            print(f"no matches in {extension_identifier}")
                else:
                    print(f"Failed to download VSIX package of {extension_identifier}")
        else:
            print("Failed to retrieve data")

if __name__ == '__main__':
    main()
